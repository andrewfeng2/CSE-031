Andrew Feng, Cameron Nguyen
TPS 1:
1. Perform a search on the Internet on the difference(s) between the terms procedures, functions, and
methods.

Procdeures are a section of code that performs a specific task, it does not return a value and 
is mainly used for it side effects (like printing/ modifying variables).

Functions are similar to procedures but always return a value. It takes input parameters and produces
an output. Should be "pure" (same input always produces same output) They can exist independently of 
objects/classes.

Methods are functions that are associated with a class/object in object-oriented programming.
They have access to the object's data (attributes) and can modify the object's state.
Always belongs to a specific class

2. As we have learned in lectures, our compiled program is stored in the static part of the memory when it
is being executed. When the CPU runs a program, it executes the statements according to the statement
order (line numbers). Unless there is a branch (beq/bne) or jump (j/jal) statement, it will just
execute the next statement.

3. Load proc1.s in MARS and study the MIPS program without assembling and running it. Write an
equivalent program in C and name it proc1.c. You can treat m and n as variables declared in main.

#include <stdio.h>

int m = 10;
int n = 5;

int sum(int a, int b) {
    return a + b;
}

int main() {
    int result = sum(m, n);
    printf("%d", result);
    return 0;
}

4. In proc1.s, we use j SUM to ask the CPU to jump to the line with the label SUM and continue
running the program from there. What line number is this (i.e., the line number pointed to by label
SUM)? What does this line do?

SUM:    add $v0, $a0, $a1
Line number 19, it adds the contents of registers $a0 and $a1 and stores their sum in register $v0

5. After function SUM is over, the program is supposed to return to the line after j SUM. In the code, jr
$ra is used. Can we use j instead (assuming we can create a label for that line)?

No, if we tried to use j instead of jr $ra, we would have these problems:
The function would always return to the same fixed location, making it impossible to reuse the function 
from different places in the code. Furthermore, in this specific code, there's another issue: 
the $ra register is being set to 0, which would cause problems when returning from the function.


6. Since the return address keeps changing depending on where SUM is called, we need to save the return
address before SUM is called. At what line in proc1.s is the return address supposed to be saved? In
what register is the address saved to? What is the value of address being saved here? Does this address
value make sense?

The reutrn address is supposed to be saved on line 11 or addi $ra,$zero, 0. The address is being svaed to 
register $ra (the return address register). It is saving the value 0 ($zero+0) which is incorrect. This value
doesn't make sense because $ra should contain the return address that the program should jump to after 
executing the SUM funciton. Setting it to 0 means the program would try to return to address 0, which is
invalid.



7. Assemble the code and open the Execute tab. Here the program is listed in the Text Segment (as we have
seen this in last lab). What happens when you try to run the program? This error is due to the invalid
return address (program counter tells the CPU where to look for a statement).

You encounter an error (Error in : invalid program counter value: 0x00000000).
Step: execution terminated with errors.

8. Now, let us correct the return address value. From the Text Segment window, what is the address of the
statement that the program should return to from SUM?

The adress is 0x00400018 or addi $a0, $v0, 0

9. Modify the code so the correct return address is saved. Assemble it and look at the Text Segment again.
(DO NOT execute it yet!) Double check the return address. Is it correct? What happened? You will
know more about what happened here in later lectures.

// ... existing code ...
MAIN:   la $t0, m               # Load address of m
        lw $a0, 0($t0)          # a0 = m
        la $t0, n               # Load address of n
        lw $a1, 0($t0)         # a1 = n

        jal SUM                 # Replace la/j with jal
// ... rest of code remains the same ...

It is correct, the actual address loaded into $ra will be the memory address where the addi $a0, $v0, 0 
instruction is located in the text segment.

10. What is the new return address? Modify your code, assemble, and run the program. What is the output
of the program?

The return address is stored in register $ra. The output is 15.

11. As you can see, saving the correct return address before each procedure call is tedious. It would be nice
if the assembler can do it for us! Instead of using j to call a procedure, what operator should we use?

We would use jal or jump and link.

12. Modify the code so you do not use j to call SUM. Make sure to comment out the line where the
return address is saved (with your modifications from earlier steps).

// ... existing code ...
MAIN:   la $t0, m               # Load address of m
        lw $a0, 0($t0)          # a0 = m
        la $t0, n               # Load address of n
        lw $a1, 0($t0)         # a1 = n

        jal SUM                 # Replace la/j with jal
// ... rest of code remains the same ...


TPS activity 2: Discuss questions 1 – 6 (25 minutes) with your TPS partners in your assigned group and
record your answers in tpsAnswers.txt under a section labelled “TPS 2”:

1. Study proc2.c and trace the program. What will be the output if you run the program? Compile and
run proc2.c in a terminal (or any IDE) and verify your answer.

The output of the program will be 38. 

2. Load proc2.s in MARS. This is the MIPS version of proc2.c. Do not assemble and run this
program, as there are errors due to the misuse of registers. Study the MAIN function and discuss with
your partners about what it does (compare it with the C version).

The main issue is that the code doesn't follow proper register preservation conventions:
$s0 and $s1 are used in MAIN without being saved
SUM uses $s0 without saving it
SUM calls SUB but doesn't save $ra
Comparison with C version:
The logic matches the C code:
It loads x=5 and y=10
Calls sum(x)
Performs y = y + x + sum(x)
Prints the result
The SUB function is correctly saving/restoring $s0, but it's the only function following proper register conventions.

3. When MAIN calls SUM, SUM knows where to return to. Why? After SUM called SUB, what happens to the
address returning to MAIN? Discuss with your partners about how you would resolve this problem. Do
not attempt to fix it yet, as we have more problems to come.

It knows where to reutrn to because when jal SUM is executed in MAIN, the jal (jump and link) instruction automatically stores the return address 
(the next instruction after the jump) in register $ra ($31)
This allows SUM to know where to return to by using jr $ra.  When SUM executes jal SUB, it overwrites the previous 
return address in $ra with the new return address (the next instruction in SUM).
This means the original return address to MAIN is lost, as $ra now contains the address to return to SUM instead. 


4. The input argument (n) in function SUM is used to call the next function, SUB, as well as being added to
the return value. According to the register convention, the first argument of all function calls must be
stored in $a0. From line 27 of proc2.s, the value in $a0 is no longer the same as the input argument
of SUM (it has been changed to store input argument of SUB). We can resolve this problem by saving the
original $a0 into a temporary register, but we may eventually run out of registers if our program is large.
Discuss with your partners about how you would resolve this problem. Do not attempt to fix it yet.

We can save $a0 on the stack along with the other saved registers.
This is the most scalable solution as it doesn't depend on register availability.

5. Have a look at line 24. What happens to the original value in $s0 from MAIN after this statement is
executed? Is this a problem? Why? Discuss with your partners about how you would fix this problem.
Do not attempt to fix it yet.

It is a problem it occurs because $s0 is being overwritten in the SUM function without being preserved.
In MAIN, $s0 is loaded with value of x (5).
When SUM is called, it overwrites $s0 with value of m (15) without saving the original value.
When returning to MAIN, the original value of x in $s0 is lost.


6. Now we know that SUM needs to backup 3 values before calling SUB. Insert prologue and epilogue into
the code so the program will run correctly. (Hint: study function SUB, as it does not contain any errors)

// ... existing code ...

SUM:    # Prologue
        addiu $sp, $sp, -12    # Make space for 3 items
        sw $ra, 8($sp)         # Save return address
        sw $a0, 4($sp)         # Save input argument
        sw $s0, 0($sp)         # Save s0 from MAIN
        
        la $t0, m
        lw $s0, 0($t0)        # s0 = m
        addu $a0, $s0, $a0    # Update a0 for SUB
        jal SUB
        
        # After SUB returns
        lw $a0, 4($sp)        # Restore original input
        addu $v0, $a0, $v0    # Add input to SUB result
        
        # Epilogue
        lw $s0, 0($sp)        # Restore s0
        lw $ra, 8($sp)        # Restore return address
        addiu $sp, $sp, 12    # Restore stack pointer
        jr $ra

// ... existing code ...



Individual Assignment 1: Create proc3.s
Study the proc3.c and re-write the same program in MIPS with the following requirements:
1. Local variables mapping:
a. main(): x → $s0, y → $s1, z → $s2
b. foo(): p → $s0, q → $s1
2. Input arguments mappings:
a. foo(): m → $a0, n → $a1, o → $a2
b. bar(): a → $a0, b → $a1, c → $a2
3. All return values from a function must be stored in V registers in ascending order (i.e. $v0, $v1).
4. Use of stack memory according to register convention.